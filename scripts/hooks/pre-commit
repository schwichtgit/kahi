#!/bin/bash
set -euo pipefail

# Git pre-commit hook.
# Checks staged files for forbidden files, secrets, and lint issues.

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [[ -z "$STAGED_FILES" ]]; then
    exit 0
fi

ERRORS=0

# --- Check for forbidden files ---
check_forbidden_files() {
    local file="$1"
    local basename
    basename=$(basename "$file")

    case "$basename" in
        .env|.env.*) return 1 ;;
        id_rsa*|id_ed25519*|id_ecdsa*|authorized_keys|known_hosts) return 1 ;;
        *.pem|*.key|*.crt|*.p12|*.pfx|*.keystore) return 1 ;;
        credentials.json|service-account*.json|aws-credentials) return 1 ;;
    esac

    if echo "$file" | grep -qE '/(\.ssh|\.gnupg|\.aws|\.gcloud)/'; then
        return 1
    fi

    return 0
}

# --- Check for secrets in staged content ---
check_for_secrets() {
    local file="$1"
    local content
    content=$(git show ":$file" 2>/dev/null || echo "")

    if [[ -z "$content" ]]; then
        return 0
    fi

    # AWS keys
    if echo "$content" | grep -qE 'AKIA[0-9A-Z]{16}'; then
        echo "  SECRET: AWS key pattern in $file" >&2
        return 1
    fi

    # OpenAI keys
    if echo "$content" | grep -qE 'sk-[a-zA-Z0-9]{48}'; then
        echo "  SECRET: OpenAI key pattern in $file" >&2
        return 1
    fi

    # GitHub tokens
    if echo "$content" | grep -qE '(ghp_|gho_)[a-zA-Z0-9]{36}'; then
        echo "  SECRET: GitHub token pattern in $file" >&2
        return 1
    fi

    # GitLab tokens
    if echo "$content" | grep -qE 'glpat-[a-zA-Z0-9_-]{20}'; then
        echo "  SECRET: GitLab token pattern in $file" >&2
        return 1
    fi

    # Slack tokens
    if echo "$content" | grep -qE 'xoxb-[0-9]{10,}'; then
        echo "  SECRET: Slack token pattern in $file" >&2
        return 1
    fi

    # Generic password/secret/token assignments
    if echo "$content" | grep -qiE '(password|secret|api_key|token)\s*[=:]\s*["\x27][^\s"'\'']{8,}'; then
        echo "  SECRET: Possible credential assignment in $file" >&2
        return 1
    fi

    return 0
}

# --- Find nearest project root for a file ---
find_project_root() {
    local dir="$1"
    while [[ "$dir" != "." ]] && [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/package.json" ]] || [[ -f "$dir/Cargo.toml" ]] || \
           [[ -f "$dir/pyproject.toml" ]] || [[ -f "$dir/go.mod" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    # Check current directory
    for marker in package.json Cargo.toml pyproject.toml go.mod; do
        if [[ -f "./$marker" ]]; then
            echo "."
            return 0
        fi
    done
    return 1
}

# --- Lint staged files ---
lint_staged_files() {
    local file="$1"
    local ext="${file##*.}"
    local dir
    dir=$(dirname "$file")

    # Skip generated files
    case "$file" in
        *_pb2.py|*_pb2_grpc.py) return 0 ;;
    esac

    local project_root
    project_root=$(find_project_root "$dir") || return 0

    case "$ext" in
        ts|tsx|js|jsx)
            if [[ -f "$project_root/node_modules/.bin/eslint" ]]; then
                npx --prefix "$project_root" eslint "$file" --quiet 2>/dev/null || return 1
            fi
            ;;
        py)
            if command -v ruff >/dev/null 2>&1; then
                ruff check "$file" 2>/dev/null || return 1
            fi
            ;;
        rs)
            # Clippy runs on the whole crate, skip per-file
            ;;
        sh)
            if command -v shellcheck >/dev/null 2>&1; then
                shellcheck "$file" 2>/dev/null || return 1
            fi
            ;;
        go)
            if command -v go >/dev/null 2>&1; then
                (cd "$project_root" && go vet "./$dir/..." 2>/dev/null) || return 1
            fi
            ;;
    esac

    return 0
}

# --- Main ---
echo "Pre-commit: checking staged files..."

for file in $STAGED_FILES; do
    # Check forbidden files
    if ! check_forbidden_files "$file"; then
        echo "BLOCKED: Forbidden file: $file" >&2
        ERRORS=$((ERRORS + 1))
        continue
    fi

    # Check for secrets
    if ! check_for_secrets "$file"; then
        ERRORS=$((ERRORS + 1))
        continue
    fi

    # Lint
    if ! lint_staged_files "$file"; then
        echo "LINT FAIL: $file" >&2
        ERRORS=$((ERRORS + 1))
    fi
done

if [[ "$ERRORS" -gt 0 ]]; then
    echo "" >&2
    echo "Pre-commit failed: $ERRORS issue(s) found." >&2
    exit 1
fi

exit 0
